Java 开发设计模式


23设计模式

创建形模式： 五种
1.工厂模式
2.抽象工厂模式
3.单例模式
4.建造者模式
5.原型模式

结构模式： 7种
1.适配器模式
2.装饰模式
3.代理模式
4.外观模式
5.桥接模式
6.组合模式
7.享元模式

行为模式： 11种

类与类
  
1.策略模式
2.模板方法模式
3.观察者模式
4.迭代子模式

类与父类

5.责任链模式
6.命令模式

类状态设计模式

7.备忘录模式
8.状态模式

中间类设计模式

9.访问者模式
10.中间者模式
11.解释器模式



Spring  aop  代理模式

# 工厂模式

大量相同场景需要创建，将多个实现类在里面实现。调用都是在工厂类里面实现的

## 1.常见工厂模式

一般的实现就是使用的常见工厂类。通过创建对象，调用工厂类里面集成的方法，实现相关目的。这样，一个工厂类就可以被多个对象调用，感觉耦合度较高，一旦这个工厂类修改，调用它的相关类一定会受影响。

​	但是代码的复用率很高。

下面是相关代码：

1.工厂接口与相关实现类

```java
package com.designModel.factory;

public interface Sender {
    /**
     * 工厂实现方法
     */
    void SenderA();
}
//一号工厂继承类
class SenderAimpl implements Sender{
    @Override
    public void SenderA() {
        System.out.println("这里是大工厂的001类");
    }
}

//二号工厂继承类
class SenderBimpl implements Sender{
    @Override
    public void SenderA() {
        System.out.println("这里是大工厂的002类");
    }
}
```

2.工厂类

```java
package com.designModel.factory;

public class SenderFactory {
    //工厂方法
    public Sender FunA(String type){
        if(type.equals("001")){
            return new SenderAimpl();
        }else if(type.equals("002")){
            return new SenderBimpl();
        }else{
            System.out.println("传入类型有问题！");
            return null;
        }
    }
}
```

3.测试类

```java
package com.designModel.factory;

public class FactoryTest {
    public static void main(String[] args) {
        SenderFactory sf = new SenderFactory();
        Sender sd = sf.FunA("003");
        sd.SenderA();
    }
}
```

## 2.多个工厂模式

就是一个工厂类里面有多个方法，可以向实现类里面可以提供多个工厂的方法。

## 3.静态工厂模式

静态工厂不用实例化就可以执行方法。

# 抽象工厂模式

多个接口方式来拓展工厂模式

目的：实现更好的拓展，在拓展中不需要对工厂类做太多改动



## 实现过程

\1. 实现俩个接口

\2. 俩个实现第一个接口的实现类

\3. 俩个实现第二个接口的实现工厂

\4. 在调用中 通过第二个实现的工厂类，来调研第一个接口的实现类

\5. 在我们扩展的时候，通过完成添加第一个接口的实现类，就能让业务扩展

 

```java
package com.designModel.factory;

/**
 * @program: Design
 * @description: 抽象工厂测试类
 * @author: sikuncheng
 * @create: 2020-07-25 15:12
 **/
public class FactoryTest02 {
    public static void main(String[] args) {
        //实例化一个第二个接口的实现类
      SenderB seb = new SenderBimpl01();
    //    SenderB seb = new SenderBimpl02();
        //通过第二个接口的实现类获取第一个接口的实现类
        Sender se = seb.sendSender();
        //执行第一个接口统一方法
        se.SenderA();
    }
}

//工厂接口实现类1
class SenderBimpl01 implements SenderB {

    @Override
    public Sender sendSender() {
        return new Senderimpl01();
    }
}

//工厂接口实现类2
class SenderBimpl02 implements SenderB {

    @Override
    public Sender sendSender() {
        return new Senderimpl02();
    }
}

//一号工厂继承类
class Senderimpl01 implements Sender {
    @Override
    public void SenderA() {
        System.out.println("这里是大工厂的001类");
    }
}

//二号工厂继承类
class Senderimpl02 implements Sender {
    @Override
    public void SenderA() {
        System.out.println("这里是大工厂的002类");
    }

}
```

这样用一个新的接口来实现老的接口。这样就可以在老的接口里面实现添加新的方法并实现来满足各种需求了。

# 建造模式

英文：

Builder

 介绍:

工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的

 

实现:

```java
package com.designModel.builder;

import java.util.ArrayList;
import java.util.List;

public class BuilderTest {
    private List<String> list = new ArrayList<String>();

    public void BuilderA(int c){
        for (int i = 0; i < c; i++) {
            list.add(new String("asd"));
        }
    }

    public void BuilderB(int c){
        for (int i = 0; i < c; i++) {
            list.add(new String("asdx"));
        }
    }
    public void print(){
        System.out.println(list);
    }

    public static void main(String[] args) {
        BuilderTest builderTest = new BuilderTest();
        builderTest.BuilderA(3);
        builderTest.print();

    }
}
```

 这里面，将需要实现的功能在类里面通过方法实现，之后在通过构造对象，调用相关方法来实现之后要实现的功能。

总结：

​	从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。

# 单例模式
英文：

Singleton



介绍：

​	单例模式中能保证 一个jvm 中只有一个实例

 

优势：

1. 对于一些创建比较频繁的类，多次创建特别大的类对象，对内存是会造成很大的开销
2. 省去了new操作，降低系统内存使用频率，减轻GC回收压力
3. 交易项目，要保证系统流程唯一性，只能使用单例模式保证线程安全性

 

### 1.实现普通单例：

 

```java
public class SingletonTest {
    //私有静态实例，目的是实现延迟加载
    private static SingletonTest ourInstance = null;

    //静态方法，创建实例
    public static SingletonTest getInstance() {
        if (ourInstance == null)
            ourInstance = new SingletonTest();
        return ourInstance;
    }
    //构造私有方法，防止被实例化
    private SingletonTest() {
    }

    //如果该对象被序列号，可以保证序列号前后一致
    public Object readResolve(){
        return ourInstance;
    }
}
```

### 2.用getInstance 方法加 synchronized关键字

 

```java
public class SingletonTest {
    //私有静态实例，目的是实现延迟加载
    private static SingletonTest ourInstance = null;

    //构造私有方法，防止被实例化
    private SingletonTest() {
    }

    //静态方法，创建实例
    public static SingletonTest getInstance() {
        if (ourInstance == null){
            synchronized (ourInstance){
                if (ourInstance == null)
                    ourInstance = new SingletonTest();
            }
        }
        return ourInstance;
    }


    //如果该对象被序列号，可以保证序列号前后一致
    public Object readResolve(){
        return ourInstance;
    }
}
```

### 3.单例模式,通过静态工厂模式实现单例

```java
public class SingletonTestB {
    private SingletonTestB(){}

    private static class SingletonFactory{
        private static SingletonTestB instance = new SingletonTestB();
    }

    public static SingletonTestB getInstance(){
        return SingletonFactory.instance;
    }

    public Object readResolve(){
        return getInstance();
    }
}
```

### 4.通过创建和实例分开

```java
public class SingletonTestC {
    public static SingletonTestC instance = null;

    private SingletonTestC(){}

    //实例
    private static synchronized void synclinit(){
        if (instance == null)
            instance = new SingletonTestC();
    }

    //创建
    public static SingletonTestC getInstance(){
        if (instance == null)
            synclinit();
        return instance;
    }


    public Object readResolve(){
        return getInstance();
    }
}
```

### 5.优化getinstance方法

```java
public class SingletonTestD {
    public static SingletonTestD instance = null;

    private Vector properties = null;
    public Vector getProperties(){
        return properties;
    }
    //防止实例化
    private SingletonTestD(){}

    //实例
    private static synchronized void synclinit(){
        if (instance == null)
            instance = new SingletonTestD();
    }

    //创建
    public static SingletonTestD getInstance(){
        if (instance == null)
            synclinit();
        return instance;
    }
//通过updateProperties()来更新对象，并且
    public void updateProperties(){
        SingletonTestD sd =new SingletonTestD();
        properties = sd.getProperties();
    }

    public Object readResolve(){
        return getInstance();
    }
}
```

因Java 创建对象和赋值步骤是分开的，多线程下进一步优化 

总结一个完美的单例模式

为创建类和 获取实例 步骤分开 单独加synchronized 实现

 

### 5.影子模式实现

 

总结：

​	Synchronized 关键字锁得死对象，一定要用对地方，锁的对象，有的时候不需要吧整个过程全部锁住

采用类的静态也可以实现单例

静态类不可以被继承，普通类可以被继承

通过静态类特点和普通类特点的结合，实现项目中各种业务


 