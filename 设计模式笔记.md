Java 开发设计模式


23设计模式

创建形模式： 五种
1.工厂模式
2.抽象工厂模式
3.单例模式
4.建造者模式
5.原型模式

结构模式： 7种
1.适配器模式
2.装饰模式
3.代理模式
4.外观模式
5.桥接模式
6.组合模式
7.享元模式

行为模式： 11种

类与类
  
1.策略模式
2.模板方法模式
3.观察者模式
4.迭代子模式

类与父类

5.责任链模式
6.命令模式

类状态设计模式

7.备忘录模式
8.状态模式

中间类设计模式

9.访问者模式
10.中间者模式
11.解释器模式



Spring  aop  代理模式

# 工厂模式

大量相同场景需要创建，将多个实现类在里面实现。调用都是在工厂类里面实现的

## 1.常见工厂模式

一般的实现就是使用的常见工厂类。通过创建对象，调用工厂类里面集成的方法，实现相关目的。这样，一个工厂类就可以被多个对象调用，感觉耦合度较高，一旦这个工厂类修改，调用它的相关类一定会受影响。

​	但是代码的复用率很高。

下面是相关代码：

1.工厂接口与相关实现类

```java
package com.designModel.factory;

public interface Sender {
    /**
     * 工厂实现方法
     */
    void SenderA();
}
//一号工厂继承类
class SenderAimpl implements Sender{
    @Override
    public void SenderA() {
        System.out.println("这里是大工厂的001类");
    }
}

//二号工厂继承类
class SenderBimpl implements Sender{
    @Override
    public void SenderA() {
        System.out.println("这里是大工厂的002类");
    }
}
```

2.工厂类

```java
package com.designModel.factory;

public class SenderFactory {
    //工厂方法
    public Sender FunA(String type){
        if(type.equals("001")){
            return new SenderAimpl();
        }else if(type.equals("002")){
            return new SenderBimpl();
        }else{
            System.out.println("传入类型有问题！");
            return null;
        }
    }
}
```

3.测试类

```java
package com.designModel.factory;

public class FactoryTest {
    public static void main(String[] args) {
        SenderFactory sf = new SenderFactory();
        Sender sd = sf.FunA("003");
        sd.SenderA();
    }
}
```

## 2.多个工厂模式

就是一个工厂类里面有多个方法，可以向实现类里面可以提供多个工厂的方法。

## 3.静态工厂模式

静态工厂不用实例化就可以执行方法。

# 抽象工厂模式

多个接口方式来拓展工厂模式

目的：实现更好的拓展，在拓展中不需要对工厂类做太多改动



## 实现过程

\1. 实现俩个接口

\2. 俩个实现第一个接口的实现类

\3. 俩个实现第二个接口的实现工厂

\4. 在调用中 通过第二个实现的工厂类，来调研第一个接口的实现类

\5. 在我们扩展的时候，通过完成添加第一个接口的实现类，就能让业务扩展

 

```java
package com.designModel.factory;

/**
 * @program: Design
 * @description: 抽象工厂测试类
 * @author: sikuncheng
 * @create: 2020-07-25 15:12
 **/
public class FactoryTest02 {
    public static void main(String[] args) {
        //实例化一个第二个接口的实现类
      SenderB seb = new SenderBimpl01();
    //    SenderB seb = new SenderBimpl02();
        //通过第二个接口的实现类获取第一个接口的实现类
        Sender se = seb.sendSender();
        //执行第一个接口统一方法
        se.SenderA();
    }
}

//工厂接口实现类1
class SenderBimpl01 implements SenderB {

    @Override
    public Sender sendSender() {
        return new Senderimpl01();
    }
}

//工厂接口实现类2
class SenderBimpl02 implements SenderB {

    @Override
    public Sender sendSender() {
        return new Senderimpl02();
    }
}

//一号工厂继承类
class Senderimpl01 implements Sender {
    @Override
    public void SenderA() {
        System.out.println("这里是大工厂的001类");
    }
}

//二号工厂继承类
class Senderimpl02 implements Sender {
    @Override
    public void SenderA() {
        System.out.println("这里是大工厂的002类");
    }

}
```

这样用一个新的接口来实现老的接口。这样就可以在老的接口里面实现添加新的方法并实现来满足各种需求了。

# 建造模式

英文：

Builder

 介绍:

工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的

 

实现:

```java
package com.designModel.builder;

import java.util.ArrayList;
import java.util.List;

public class BuilderTest {
    private List<String> list = new ArrayList<String>();

    public void BuilderA(int c){
        for (int i = 0; i < c; i++) {
            list.add(new String("asd"));
        }
    }

    public void BuilderB(int c){
        for (int i = 0; i < c; i++) {
            list.add(new String("asdx"));
        }
    }
    public void print(){
        System.out.println(list);
    }

    public static void main(String[] args) {
        BuilderTest builderTest = new BuilderTest();
        builderTest.BuilderA(3);
        builderTest.print();

    }
}
```

 这里面，将需要实现的功能在类里面通过方法实现，之后在通过构造对象，调用相关方法来实现之后要实现的功能。

总结：

​	从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。

# 单例模式
英文：

Singleton



介绍：

​	单例模式中能保证 一个jvm 中只有一个实例

 

优势：

1. 对于一些创建比较频繁的类，多次创建特别大的类对象，对内存是会造成很大的开销
2. 省去了new操作，降低系统内存使用频率，减轻GC回收压力
3. 交易项目，要保证系统流程唯一性，只能使用单例模式保证线程安全性

 

### 1.实现普通单例：

 

```java
public class SingletonTest {
    //私有静态实例，目的是实现延迟加载
    private static SingletonTest ourInstance = null;

    //静态方法，创建实例
    public static SingletonTest getInstance() {
        if (ourInstance == null)
            ourInstance = new SingletonTest();
        return ourInstance;
    }
    //构造私有方法，防止被实例化
    private SingletonTest() {
    }

    //如果该对象被序列号，可以保证序列号前后一致
    public Object readResolve(){
        return ourInstance;
    }
}
```

### 2.用getInstance 方法加 synchronized关键字

 

```java
public class SingletonTest {
    //私有静态实例，目的是实现延迟加载
    private static SingletonTest ourInstance = null;

    //构造私有方法，防止被实例化
    private SingletonTest() {
    }

    //静态方法，创建实例
    public static SingletonTest getInstance() {
        if (ourInstance == null){
            synchronized (ourInstance){
                if (ourInstance == null)
                    ourInstance = new SingletonTest();
            }
        }
        return ourInstance;
    }


    //如果该对象被序列号，可以保证序列号前后一致
    public Object readResolve(){
        return ourInstance;
    }
}
```

### 3.单例模式,通过静态工厂模式实现单例

```java
public class SingletonTestB {
    private SingletonTestB(){}

    private static class SingletonFactory{
        private static SingletonTestB instance = new SingletonTestB();
    }

    public static SingletonTestB getInstance(){
        return SingletonFactory.instance;
    }

    public Object readResolve(){
        return getInstance();
    }
}
```

### 4.通过创建和实例分开

```java
public class SingletonTestC {
    public static SingletonTestC instance = null;

    private SingletonTestC(){}

    //实例
    private static synchronized void synclinit(){
        if (instance == null)
            instance = new SingletonTestC();
    }

    //创建
    public static SingletonTestC getInstance(){
        if (instance == null)
            synclinit();
        return instance;
    }


    public Object readResolve(){
        return getInstance();
    }
}
```

### 5.优化getinstance方法

```java
public class SingletonTestD {
    public static SingletonTestD instance = null;

    private Vector properties = null;
    public Vector getProperties(){
        return properties;
    }
    //防止实例化
    private SingletonTestD(){}

    //实例
    private static synchronized void synclinit(){
        if (instance == null)
            instance = new SingletonTestD();
    }

    //创建
    public static SingletonTestD getInstance(){
        if (instance == null)
            synclinit();
        return instance;
    }
//通过updateProperties()来更新对象，并且
    public void updateProperties(){
        SingletonTestD sd =new SingletonTestD();
        properties = sd.getProperties();
    }

    public Object readResolve(){
        return getInstance();
    }
}
```

因Java 创建对象和赋值步骤是分开的，多线程下进一步优化 

总结一个完美的单例模式

为创建类和 获取实例 步骤分开 单独加synchronized 实现

 

### 5.影子模式实现

 

总结：

​	Synchronized 关键字锁得死对象，一定要用对地方，锁的对象，有的时候不需要吧整个过程全部锁住

采用类的静态也可以实现单例

静态类不可以被继承，普通类可以被继承

通过静态类特点和普通类特点的结合，实现项目中各种业务

 

# 原型模式 

英文：

Prototype

介绍

 原型模式与IO流密切相关。

​	原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的

### 1.简单实现

 最简单的圆形模式的实现类，就是实现Cloneable接口， Cloneable里面是空的，仅仅是实现一个标记实现方法属性的作用。执行super.clone()

```java
public class Prototype implements Cloneable {
    public Object clone() throws CloneNotSupportedException{
        Prototype pro = (Prototype)super.clone();
        return pro;
    }
}
```

###  2.深复制、浅复制



```java
public class PrototypeTestA implements Cloneable{
    //通过clone获得
    /*private static final long versionUid = 1L;

    private String str;*/

    private String st1 = "wangzhe001";

    public PrototypeTestA(String st) {
        st1 = st;
    }
    

    //通过clone获得浅复制
    public Object clone() throws CloneNotSupportedException {
        PrototypeTestA prototypeTestA = (PrototypeTestA) super.clone();

        return prototypeTestA;
    }

    //  深复制
    public Object deepClone() throws IOException,ClassNotFoundException{
        //将对象写入二进制
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(this);

        //读出二进制流 的对象
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);

        return ois.readObject();
    }

}
```

总结：

​	很简单，一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的.在这儿，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念：

浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。

深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。

要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。
 