Java 开发设计模式


23设计模式

创建形模式： 五种
1.工厂模式
2.抽象工厂模式
3.单例模式
4.建造者模式
5.原型模式

结构模式： 7种
1.适配器模式
2.装饰模式
3.代理模式
4.外观模式
5.桥接模式
6.组合模式
7.享元模式

行为模式： 11种

类与类
  
1.策略模式
2.模板方法模式
3.观察者模式
4.迭代子模式

类与父类

5.责任链模式
6.命令模式

类状态设计模式

7.备忘录模式
8.状态模式

中间类设计模式

9.访问者模式
10.中间者模式
11.解释器模式



Spring  aop  代理模式

# 工厂模式

大量相同场景需要创建，将多个实现类在里面实现。调用都是在工厂类里面实现的

## 1.常见工厂模式

一般的实现就是使用的常见工厂类。通过创建对象，调用工厂类里面集成的方法，实现相关目的。这样，一个工厂类就可以被多个对象调用，感觉耦合度较高，一旦这个工厂类修改，调用它的相关类一定会受影响。

​	但是代码的复用率很高。

下面是相关代码：

1.工厂接口与相关实现类

```java
package com.designModel.factory;

public interface Sender {
    /**
     * 工厂实现方法
     */
    void SenderA();
}
//一号工厂继承类
class SenderAimpl implements Sender{
    @Override
    public void SenderA() {
        System.out.println("这里是大工厂的001类");
    }
}

//二号工厂继承类
class SenderBimpl implements Sender{
    @Override
    public void SenderA() {
        System.out.println("这里是大工厂的002类");
    }
}
```

2.工厂类

```java
package com.designModel.factory;

public class SenderFactory {
    //工厂方法
    public Sender FunA(String type){
        if(type.equals("001")){
            return new SenderAimpl();
        }else if(type.equals("002")){
            return new SenderBimpl();
        }else{
            System.out.println("传入类型有问题！");
            return null;
        }
    }
}
```

3.测试类

```java
package com.designModel.factory;

public class FactoryTest {
    public static void main(String[] args) {
        SenderFactory sf = new SenderFactory();
        Sender sd = sf.FunA("003");
        sd.SenderA();
    }
}
```

## 2.多个工厂模式

就是一个工厂类里面有多个方法，可以向实现类里面可以提供多个工厂的方法。

## 3.静态工厂模式

静态工厂不用实例化就可以执行方法。

# 抽象工厂模式

多个接口方式来拓展工厂模式

目的：实现更好的拓展，在拓展中不需要对工厂类做太多改动



## 实现过程

\1. 实现俩个接口

\2. 俩个实现第一个接口的实现类

\3. 俩个实现第二个接口的实现工厂

\4. 在调用中 通过第二个实现的工厂类，来调研第一个接口的实现类

\5. 在我们扩展的时候，通过完成添加第一个接口的实现类，就能让业务扩展

 

```java
package com.designModel.factory;

/**
 * @program: Design
 * @description: 抽象工厂测试类
 * @author: sikuncheng
 * @create: 2020-07-25 15:12
 **/
public class FactoryTest02 {
    public static void main(String[] args) {
        //实例化一个第二个接口的实现类
      SenderB seb = new SenderBimpl01();
    //    SenderB seb = new SenderBimpl02();
        //通过第二个接口的实现类获取第一个接口的实现类
        Sender se = seb.sendSender();
        //执行第一个接口统一方法
        se.SenderA();
    }
}

//工厂接口实现类1
class SenderBimpl01 implements SenderB {

    @Override
    public Sender sendSender() {
        return new Senderimpl01();
    }
}

//工厂接口实现类2
class SenderBimpl02 implements SenderB {

    @Override
    public Sender sendSender() {
        return new Senderimpl02();
    }
}

//一号工厂继承类
class Senderimpl01 implements Sender {
    @Override
    public void SenderA() {
        System.out.println("这里是大工厂的001类");
    }
}

//二号工厂继承类
class Senderimpl02 implements Sender {
    @Override
    public void SenderA() {
        System.out.println("这里是大工厂的002类");
    }

}
```

这样用一个新的接口来实现老的接口。这样就可以在老的接口里面实现添加新的方法并实现来满足各种需求了。

# 建造模式

英文：

Builder

 介绍:

工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的

 

实现:

```java
package com.designModel.builder;

import java.util.ArrayList;
import java.util.List;

public class BuilderTest {
    private List<String> list = new ArrayList<String>();

    public void BuilderA(int c){
        for (int i = 0; i < c; i++) {
            list.add(new String("asd"));
        }
    }

    public void BuilderB(int c){
        for (int i = 0; i < c; i++) {
            list.add(new String("asdx"));
        }
    }
    public void print(){
        System.out.println(list);
    }

    public static void main(String[] args) {
        BuilderTest builderTest = new BuilderTest();
        builderTest.BuilderA(3);
        builderTest.print();

    }
}
```

 这里面，将需要实现的功能在类里面通过方法实现，之后在通过构造对象，调用相关方法来实现之后要实现的功能。

总结：

​	从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。

 