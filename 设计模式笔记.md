Java 开发设计模式


23设计模式

创建形模式： 五种
1.工厂模式
2.抽象工厂模式
3.单例模式
4.建造者模式
5.原型模式

结构模式： 7种
1.适配器模式
2.装饰模式
3.代理模式
4.外观模式
5.桥接模式
6.组合模式
7.享元模式

行为模式： 11种

类与类
  
1.策略模式
2.模板方法模式
3.观察者模式
4.迭代子模式

类与父类

5.责任链模式
6.命令模式

类状态设计模式

7.备忘录模式
8.状态模式

中间类设计模式

9.访问者模式
10.中间者模式
11.解释器模式



Spring  aop  代理模式

# 工厂模式

大量相同场景需要创建，将多个实现类在里面实现。调用都是在工厂类里面实现的

## 1.常见工厂模式

一般的实现就是使用的常见工厂类。通过创建对象，调用工厂类里面集成的方法，实现相关目的。这样，一个工厂类就可以被多个对象调用，感觉耦合度较高，一旦这个工厂类修改，调用它的相关类一定会受影响。

​	但是代码的复用率很高。

下面是相关代码：

1.工厂接口与相关实现类

```java
package com.designModel.factory;

public interface Sender {
    /**
     * 工厂实现方法
     */
    void SenderA();
}
//一号工厂继承类
class SenderAimpl implements Sender{
    @Override
    public void SenderA() {
        System.out.println("这里是大工厂的001类");
    }
}

//二号工厂继承类
class SenderBimpl implements Sender{
    @Override
    public void SenderA() {
        System.out.println("这里是大工厂的002类");
    }
}
```

2.工厂类

```java
package com.designModel.factory;

public class SenderFactory {
    //工厂方法
    public Sender FunA(String type){
        if(type.equals("001")){
            return new SenderAimpl();
        }else if(type.equals("002")){
            return new SenderBimpl();
        }else{
            System.out.println("传入类型有问题！");
            return null;
        }
    }
}
```

3.测试类

```java
package com.designModel.factory;

public class FactoryTest {
    public static void main(String[] args) {
        SenderFactory sf = new SenderFactory();
        Sender sd = sf.FunA("003");
        sd.SenderA();
    }
}
```

## 2.多个工厂模式

就是一个工厂类里面有多个方法，可以向实现类里面可以提供多个工厂的方法。

## 3.静态工厂模式

静态工厂不用实例化就可以执行方法。

# 抽象工厂模式

多个接口方式来拓展工厂模式

目的：实现更好的拓展，在拓展中不需要对工厂类做太多改动



## 实现过程

\1. 实现俩个接口

\2. 俩个实现第一个接口的实现类

\3. 俩个实现第二个接口的实现工厂

\4. 在调用中 通过第二个实现的工厂类，来调研第一个接口的实现类

\5. 在我们扩展的时候，通过完成添加第一个接口的实现类，就能让业务扩展

 

```java
package com.designModel.factory;

/**
 * @program: Design
 * @description: 抽象工厂测试类
 * @author: sikuncheng
 * @create: 2020-07-25 15:12
 **/
public class FactoryTest02 {
    public static void main(String[] args) {
        //实例化一个第二个接口的实现类
      SenderB seb = new SenderBimpl01();
    //    SenderB seb = new SenderBimpl02();
        //通过第二个接口的实现类获取第一个接口的实现类
        Sender se = seb.sendSender();
        //执行第一个接口统一方法
        se.SenderA();
    }
}

//工厂接口实现类1
class SenderBimpl01 implements SenderB {

    @Override
    public Sender sendSender() {
        return new Senderimpl01();
    }
}

//工厂接口实现类2
class SenderBimpl02 implements SenderB {

    @Override
    public Sender sendSender() {
        return new Senderimpl02();
    }
}

//一号工厂继承类
class Senderimpl01 implements Sender {
    @Override
    public void SenderA() {
        System.out.println("这里是大工厂的001类");
    }
}

//二号工厂继承类
class Senderimpl02 implements Sender {
    @Override
    public void SenderA() {
        System.out.println("这里是大工厂的002类");
    }

}
```

这样用一个新的接口来实现老的接口。这样就可以在老的接口里面实现添加新的方法并实现来满足各种需求了。

# 建造模式

英文：

Builder

 介绍:

工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的

 

实现:

```java
package com.designModel.builder;

import java.util.ArrayList;
import java.util.List;

public class BuilderTest {
    private List<String> list = new ArrayList<String>();

    public void BuilderA(int c){
        for (int i = 0; i < c; i++) {
            list.add(new String("asd"));
        }
    }

    public void BuilderB(int c){
        for (int i = 0; i < c; i++) {
            list.add(new String("asdx"));
        }
    }
    public void print(){
        System.out.println(list);
    }

    public static void main(String[] args) {
        BuilderTest builderTest = new BuilderTest();
        builderTest.BuilderA(3);
        builderTest.print();

    }
}
```

 这里面，将需要实现的功能在类里面通过方法实现，之后在通过构造对象，调用相关方法来实现之后要实现的功能。

总结：

​	从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。

# 单例模式
英文：

Singleton



介绍：

​	单例模式中能保证 一个jvm 中只有一个实例

 

优势：

1. 对于一些创建比较频繁的类，多次创建特别大的类对象，对内存是会造成很大的开销
2. 省去了new操作，降低系统内存使用频率，减轻GC回收压力
3. 交易项目，要保证系统流程唯一性，只能使用单例模式保证线程安全性

 

### 1.实现普通单例：

 

```java
public class SingletonTest {
    //私有静态实例，目的是实现延迟加载
    private static SingletonTest ourInstance = null;

    //静态方法，创建实例
    public static SingletonTest getInstance() {
        if (ourInstance == null)
            ourInstance = new SingletonTest();
        return ourInstance;
    }
    //构造私有方法，防止被实例化
    private SingletonTest() {
    }

    //如果该对象被序列号，可以保证序列号前后一致
    public Object readResolve(){
        return ourInstance;
    }
}
```

### 2.用getInstance 方法加 synchronized关键字

 

```java
public class SingletonTest {
    //私有静态实例，目的是实现延迟加载
    private static SingletonTest ourInstance = null;

    //构造私有方法，防止被实例化
    private SingletonTest() {
    }

    //静态方法，创建实例
    public static SingletonTest getInstance() {
        if (ourInstance == null){
            synchronized (ourInstance){
                if (ourInstance == null)
                    ourInstance = new SingletonTest();
            }
        }
        return ourInstance;
    }


    //如果该对象被序列号，可以保证序列号前后一致
    public Object readResolve(){
        return ourInstance;
    }
}
```

### 3.单例模式,通过静态工厂模式实现单例

```java
public class SingletonTestB {
    private SingletonTestB(){}

    private static class SingletonFactory{
        private static SingletonTestB instance = new SingletonTestB();
    }

    public static SingletonTestB getInstance(){
        return SingletonFactory.instance;
    }

    public Object readResolve(){
        return getInstance();
    }
}
```

### 4.通过创建和实例分开

```java
public class SingletonTestC {
    public static SingletonTestC instance = null;

    private SingletonTestC(){}

    //实例
    private static synchronized void synclinit(){
        if (instance == null)
            instance = new SingletonTestC();
    }

    //创建
    public static SingletonTestC getInstance(){
        if (instance == null)
            synclinit();
        return instance;
    }


    public Object readResolve(){
        return getInstance();
    }
}
```

### 5.优化getinstance方法

```java
public class SingletonTestD {
    public static SingletonTestD instance = null;

    private Vector properties = null;
    public Vector getProperties(){
        return properties;
    }
    //防止实例化
    private SingletonTestD(){}

    //实例
    private static synchronized void synclinit(){
        if (instance == null)
            instance = new SingletonTestD();
    }

    //创建
    public static SingletonTestD getInstance(){
        if (instance == null)
            synclinit();
        return instance;
    }
//通过updateProperties()来更新对象，并且
    public void updateProperties(){
        SingletonTestD sd =new SingletonTestD();
        properties = sd.getProperties();
    }

    public Object readResolve(){
        return getInstance();
    }
}
```

因Java 创建对象和赋值步骤是分开的，多线程下进一步优化 

总结一个完美的单例模式

为创建类和 获取实例 步骤分开 单独加synchronized 实现

 

### 5.影子模式实现

 

总结：

​	Synchronized 关键字锁得死对象，一定要用对地方，锁的对象，有的时候不需要吧整个过程全部锁住

采用类的静态也可以实现单例

静态类不可以被继承，普通类可以被继承

通过静态类特点和普通类特点的结合，实现项目中各种业务

 

# 原型模式 

英文：

Prototype

介绍

 原型模式与IO流密切相关。

​	原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的

### 1.简单实现

 最简单的圆形模式的实现类，就是实现Cloneable接口， Cloneable里面是空的，仅仅是实现一个标记实现方法属性的作用。执行super.clone()

```java
public class Prototype implements Cloneable {
    public Object clone() throws CloneNotSupportedException{
        Prototype pro = (Prototype)super.clone();
        return pro;
    }
}
```

###  2.深复制、浅复制



```java
public class PrototypeTestA implements Cloneable{
    //通过clone获得
    /*private static final long versionUid = 1L;

    private String str;*/

    private String st1 = "wangzhe001";

    public PrototypeTestA(String st) {
        st1 = st;
    }
    

    //通过clone获得浅复制
    public Object clone() throws CloneNotSupportedException {
        PrototypeTestA prototypeTestA = (PrototypeTestA) super.clone();

        return prototypeTestA;
    }

    //  深复制
    public Object deepClone() throws IOException,ClassNotFoundException{
        //将对象写入二进制
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(this);

        //读出二进制流 的对象
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);

        return ois.readObject();
    }

}
```

总结：

​	很简单，一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的.在这儿，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念：

浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。

深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。

要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。
 
 # 适配器模式
 
 英文：
 
 Adapter
 
 介绍：
 
 ​	适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。首先，我们来看看类的适配器模式
 
 
 
 
 
 ​	类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。
 
  
 
 ```java
 public class AdapterA {
     public static void main(String[] args) {
         B b = new Adapter();
         b.method01();
         b.method02();
     }
 }
 /*
  *通过适配器类实现了
  * 让B 接口具有A类的功能
  * */
 class Adapter extends A implements B{
 
     @Override
     public void method02() {
         System.out.println("这是B接口方法");
     }
 }
 //适配器类
 class A{
     //对应的类要方法一致
     public void method01(){
         System.out.println("method01");
     }
 }
 
 interface B{
     //对应的类要方法一致
     public void method01();
     public void method02();
 ```
 
 对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。
 
 ```java
 public class AdapterObject {
     public static void main(String[] args) {
         A2 a2 = new A2();           //具体执行拓展方法类
         B2 b = new Adapter2(a2);    //调用拓展的适配类
         b.method01();
         b.method02();
     }
 }
 
 /*
  *通过适配器类实现了
  * 让B 接口具有A类的功能
  * */
 class Adapter2  implements B2{
 
     private A2 a2;
     public Adapter2(A2 a2){
         super();;
         this.a2 = a2;
     }
     //在适配器类中调用实例对象，通过实例对象的方法执行具体的method01的方法
     @Override
     public void method01() {
         a2.method01();
     }
 
     @Override
     public void method02() {
         System.out.println("这是B接口方法002");
     }
 }
 
 //适配器类
 class A2{
     //对应的类要方法一致
     public void method01(){
         System.out.println("method01");
     }
 }
 
 interface B2{
     //对应的类要方法一致
     public void method01();
     public void method02();
 }
 ```
 
 接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。
 
 ```java
 public class AdapterIn {
     public static void main(String[] args) {
         A3 a001 = new C1();
         A3 a002 = new C2();
 
         a001.method01();
         a001.method02();
         a002.method01();
         a002.method02();
     }
 }
 /*
  *   父级接口
  */
 interface A3{
     //对应的类要方法一致
     public void method01();
     public void method02();
 }
 // 抽象类实现接口方法
 abstract class Adapter3 implements A3{
     @Override
     public void method01() {
         System.out.println("hello 01");
     }
 
     @Override
     public void method02() {
         System.out.println("hello 02");
     }
 }
 class C2 extends Adapter3 {
     @Override
     public void method02() {
         System.out.println("C2重写method02");
     }
 }
 
 class C1 extends Adapter3 {
     @Override
     public void method01() {
         System.out.println("C1重写method01");
     }
 }
 ```
 
 总结：
 
 适配器模式看一遍不能掌握。要多考虑几次
 
 # 装饰模式
 
 英文：
 
 Decorator
 
  
 
 介绍
 
 ​	装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例
 
  
 
 实现：
 
  
 
 ```java
 /*A类是被装饰类，B类是装饰类，C类可以动态的添加一些功能
  *
  */
 public class Decorator {
     public static void main(String[] args) {
         //一个实现装饰接口的类
         IA a = new A();
         //调用实现装饰接口的类
         IA b = new B(a);   //重点
         //执行装饰接口的方法
         b.method();
     }
 }
 //装饰接口
 interface IA {
     public void method();
 }
 
 class A implements IA{
 
     @Override
     public void method() {
         System.out.println("我是装饰类的一个装饰内容：001");
     }
 }
 //适配器装饰类
 class B implements IA { //适配器装饰类
     private IA ia;
 
    public B(IA ia){
        super();
        this.ia = ia;
    }
 
     @Override
     public void method() {  //在执行相关任务前、后需要执行的任务
         System.out.println("之前执行");
         ia.method();
         System.out.println("之后执行");
     }
 }
 ```
 
  
 
 总结：
 
 ​	装饰器模式的应用场景：
 
 1、需要扩展一个类的功能。
 
 2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）
 
 缺点：**产生过多相似的对象，不易排错！**
 spring IOC就是使用的装饰模式
 
 # 代理模式
 
 英文：
 
 Proxy
 
 
 
 介绍：
 
 ​	其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。 
 
  
 
 实现：
 
 ```java
 public class Proxy {
     public static void main(String[] args) {
         I i1 = new A();
         I i2 = new B(i1);
         i2.method();
     }
 }
 
 interface I{
     public void method();
 }
 class A implements I{
 
     @Override
     public void method() {
         System.out.println("这里正在做任务");
     }
 }
 
 class B implements I{
     private I i;
     public B(I i){
         super();
         this.i = i;
     }
     @Override
     public void method() {
         before();
         i.method();
         after();
     }
 
     private void before() {
         System.out.println("before proxy!");
     }
 
 
     private void after() {
         System.out.println("after proxy!");
     }
 }
 ```
 
  
 
 总结：
 
 ​	如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：
 
 1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。
 
 2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。
 
 使用代理模式，可以将功能划分的更加清晰，有助于后期维护！（就是方便拓展各种功能，一般在里面增加统一的日志输出服务使用的就是代理方法）